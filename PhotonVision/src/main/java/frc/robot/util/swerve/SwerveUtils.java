package frc.robot.util.swerve;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;

public class SwerveUtils {

    public static class SwerveOptimizer{
        public static SwerveModuleState optimize(SwerveModuleState desiredState, Rotation2d currentAngle) {
            double targetAngle = placeInAppropriate0To360Scope(currentAngle.getDegrees(), desiredState.angle.getDegrees());
            double targetSpeed = desiredState.speedMetersPerSecond;
            double delta = targetAngle - currentAngle.getDegrees();
            if (Math.abs(delta) > 90){
                targetSpeed = -targetSpeed;
                targetAngle = delta > 90 ? (targetAngle -= 180) : (targetAngle += 180);
            }        
            return new SwerveModuleState(targetSpeed, Rotation2d.fromDegrees(targetAngle));
          }
        
          /**
             * @param scopeReference Current Angle
             * @param newAngle Target Angle
             * @return Closest angle within scope
             */
            private static double placeInAppropriate0To360Scope(double scopeReference, double newAngle) {
              double lowerBound;
              double upperBound;
              double lowerOffset = scopeReference % 360;
              if (lowerOffset >= 0) {
                  lowerBound = scopeReference - lowerOffset;
                  upperBound = scopeReference + (360 - lowerOffset);
              } else {
                  upperBound = scopeReference - lowerOffset;
                  lowerBound = scopeReference - (360 + lowerOffset);
              }
              while (newAngle < lowerBound) {
                  newAngle += 360;
              }
              while (newAngle > upperBound) {
                  newAngle -= 360;
              }
              if (newAngle - scopeReference > 180) {
                  newAngle -= 360;
              } else if (newAngle - scopeReference < -180) {
                  newAngle += 360;
              }
              return newAngle;
          }
    }
    

    public static class Conversions {


            /**
         * @param velocityCounts Falcon Velocity Counts
         * @param gearRatio Gear Ratio between Falcon and Mechanism (set to 1 for Falcon RPM)
         * @return RPM of Mechanism
         */
        public static double falconToRPM(double velocityCounts, double gearRatio) {
            double motorRPM = velocityCounts * (600.0 / 2048.0);        
            double mechRPM = motorRPM / gearRatio;
            return mechRPM;
        }

        /**
         * @param RPM RPM of mechanism
         * @param gearRatio Gear Ratio between Falcon and Mechanism (set to 1 for Falcon RPM)
         * @return RPM of Mechanism
         */
        public static double RPMToFalcon(double RPM, double gearRatio) {
            double motorRPM = RPM * gearRatio;
            double sensorCounts = motorRPM * (2048.0 / 600.0);
            return sensorCounts;
        }

        /**
         * @param velocitycounts Falcon Velocity Counts
         * @param circumference Circumference of Wheel
         * @param gearRatio Gear Ratio between Falcon and Mechanism (set to 1 for Falcon MPS)
         * @return Falcon Velocity Counts
         */
        public static double falconToMPS(double velocitycounts, double circumference, double gearRatio){
            double wheelRPM = falconToRPM(velocitycounts, gearRatio);
            double wheelMPS = (wheelRPM * circumference) / 60;
            return wheelMPS;
        }

        /**
         * @param positionCounts Falcon Position Counts
         * @param circumference Circumference of Wheel
         * @param gearRatio Gear Ratio between Falcon and Wheel
         * @return Meters
         */
        public static double falconToMeters(double positionCounts, double circumference, double gearRatio){
            return positionCounts * (circumference / (gearRatio * 2048.0));
        }

        /**
         * @param meters Meters
         * @param circumference Circumference of Wheel
         * @param gearRatio Gear Ratio between Falcon and Wheel
         * @return Falcon Position Counts
         */
        public static double MetersToFalcon(double meters, double circumference, double gearRatio){
            return meters / (circumference / (gearRatio * 2048.0));
        }

        /**
         * @param velocity Velocity MPS
         * @param circumference Circumference of Wheel
         * @param gearRatio Gear Ratio between Falcon and Mechanism (set to 1 for Falcon MPS)
         * @return Falcon Velocity Counts
         */
        public static double MPSToFalcon(double velocity, double circumference, double gearRatio){
            double wheelRPM = ((velocity * 60) / circumference);
            double wheelVelocity = RPMToFalcon(wheelRPM, gearRatio);
            return wheelVelocity;
        }

        /**
         * @param counts Falcon Position Counts
         * @param gearRatio Gear Ratio between Falcon and Mechanism
         * @return Degrees of Rotation of Mechanism
         */
        public static double falconToDegrees(double positionCounts, double gearRatio) {
            return positionCounts * (360.0 / (gearRatio * 2048.0));
        }

        /**
         * @param degrees Degrees of rotation of Mechanism
         * @param gearRatio Gear Ratio between Falcon and Mechanism
         * @return Falcon Position Counts
         */
        public static double degreesToFalcon(double degrees, double gearRatio) {
            return degrees / (360.0 / (gearRatio * 2048.0));
        }
    }
}
